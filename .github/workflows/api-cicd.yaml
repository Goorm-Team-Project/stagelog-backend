name: Django API SERVER CI/CD

on:
  push:
    branches: [ "develop" ] # 본인의 배포 브랜치명으로 수정
  workflow_dispatch:

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      - name: Get current time
        uses: josStorer/get-current-time@v2
        id: current-time
        with:
          format: YYYYMMDD-HHmm
          utcOffset: "+09:00" # 한국 시간 기준
      
      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/api/Dockerfile # 아까 확인한 실제 경로!
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/stagelog-repo:api
            ${{ secrets.DOCKERHUB_USERNAME }}/stagelog-repo:api-${{ steps.current-time.outputs.formattedTime }}

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    steps:

      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Create .env file
        run: |
          echo "SECRET_KEY=${{ secrets.SECRET_KEY }}" >> .env
          echo "DEBUG=${{ secrets.DEBUG }}" >> .env
          echo "ALLOWED_HOSTS=${{ secrets.ALLOWED_HOSTS }}" >> .env

          echo "DATABASE_URL=${{ secrets.DATABASE_URL_MANAGED }}" >> .env
          echo "DB_PASSWORD=${{ secrets.DB_PASSWORD }}" >> .env
          echo "DB_HOST=${{ secrets.DB_HOST_MANAGED }}" >> .env
          echo "DB_MODE=${{ secrets.DB_MODE }}" >> .env

          echo "KAKAO_REST_API_KEY=${{ secrets.KAKAO_REST_API_KEY }}" >> .env
          echo "KAKAO_REDIRECT_URI=${{ secrets.KAKAO_REDIRECT_URI }}" >> .env
          echo "KAKAO_ACCESS_TOKEN_CLIENT_SECRET=${{ secrets.KAKAO_ACCESS_TOKEN_CLIENT_SECRET }}" >> .env
          echo "KAKAO_TOKEN_REQ_URL=${{ secrets.KAKAO_TOKEN_REQ_URL }}" >> .env

          echo "NAVER_REST_API_KEY=${{ secrets.NAVER_REST_API_KEY }}" >> .env
          echo "NAVER_REDIRECT_URI=${{ secrets.NAVER_REDIRECT_URI }}" >> .env
          echo "NAVER_ACCESS_TOKEN_CLIENT_SECRET=${{ secrets.NAVER_ACCESS_TOKEN_CLIENT_SECRET }}" >> .env
          echo "NAVER_TOKEN_REQ_URL=${{ secrets.NAVER_TOKEN_REQ_URL }}" >> .env

          echo "GOOGLE_REST_API_KEY=${{ secrets.GOOGLE_REST_API_KEY }}" >> .env
          echo "GOOGLE_REDIRECT_URI=${{ secrets.GOOGLE_REDIRECT_URI }}" >> .env
          echo "GOOGLE_ACCESS_TOKEN_CLIENT_SECRET=${{ secrets.GOOGLE_ACCESS_TOKEN_CLIENT_SECRET }}" >> .env
          
          echo "JWT_EXP_DELTA_SECONDS=${{ secrets.JWT_EXP_DELTA_SECONDS }}" >> .env
          echo "API_PORT=${{ secrets.API_PORT }}" >> .env

          echo "AWS_REGION=${{ secrets.AWS_REGION }}" >> .env
          echo "S3_UPLOAD_BUCKET=${{ secrets.S3_UPLOAD_BUCKET }}" >> .env          
          echo "S3_UPLOAD_PREFIX=${{ secrets.S3_UPLOAD_PREFIX }}" >> .env
          echo "S3_PRESIGN_EXPIRES=${{ secrets.S3_PRESIGN_EXPIRES }}" >> .env
          


      # - name: Get GitHub Action IP
      #   id: ip
      #   run: echo "ipv4=$(curl -s https://ifconfig.me)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      # - name: Add GitHub IP to Security Group
      #   run: |
      #     aws ec2 authorize-security-group-ingress \
      #       --group-id ${{ secrets.AWS_SG_ID }} \
      #       --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32
      
      #SSM을 이용해서 env파일과 docker-compse.yml 전송 및 컨테이너 실행
      - name: Deploy to Private EC2 via SSM
        run: |
          # 1. 태그로 인스턴스 찾아서 할당하기
          INSTANCE_IDS=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=stagelog-ec2-backend" "Name=instance-state-name,Values=running" \
            --query "Reservations[*].Instances[*].InstanceId" \
            --output text)
          # 1-1. 인스턴스가 없다면 실행 중지
          if [ -z "$INSTANCE_ID" ]; then
            echo "에러: 해당 태그를 가진 실행 중인 인스턴스를 찾을 수 없습니다."
            exit 1
          fi
          
          # 2. SSM 연결 확인
          for INSTANCE_ID in $INSTANCE_IDS; do
          echo "SSM 상태 확인: $INSTANCE_ID"

            while true; do
              STATUS=$(aws ssm describe-instance-information \
                --filters "Key=InstanceIds,Values=$INSTANCE_ID" \
                --query "InstanceInformationList[0].PingStatus" \
                --output text)

              if [ "$STATUS" == "Online" ]; then
                echo "$INSTANCE_ID SSM Online"
                break
              fi

              echo "대기 중..."
              sleep 10
            done
          done
          
          # 3. Base64 인코딩 (줄바꿈/특수문자 보호)
          ENV_BASE64=$(base64 -w 0 .env)
          DOCKER_COMPOSE_BASE64=$(base64 -w 0 docker-compose.yml)

          
          # 4. SSM 명령 전달 (파일 생성부터 실행까지 한 번에)
          # 'chown -R ec2-user:ec2-user /home/ec2-user/stagelog-api' ssm으로 만들어진 폴더의 권한 변경
          aws ssm send-command \
            --instance-ids $INSTANCE_IDS \
            --document-name "AWS-RunShellScript" \
            --region ap-northeast-2 \
            --parameters "commands=[
              'mkdir -p /home/ec2-user/stagelog-api',
              'echo \"$ENV_BASE64\" | base64 -d > /home/ec2-user/stagelog-api/.env',
              'echo \"$DOCKER_COMPOSE_BASE64\" | base64 -d > /home/ec2-user/stagelog-api/docker-compose.yml',
              'chown -R ec2-user:ec2-user /home/ec2-user/stagelog-api',
              'cd /home/ec2-user/stagelog-api',
              'echo \"${{ secrets.DOCKERHUB_TOKEN }}\" | docker login -u \"${{ secrets.DOCKERHUB_USERNAME }}\" --password-stdin',
              'docker-compose pull',
              'docker-compose up -d',
              'docker image prune -f'
            ]"

      # #docker-compose.yml과 관련 설정 폴더를 모두 보냅니다.
      # - name: Copy files to EC2
      #   uses: appleboy/scp-action@v0.1.7
      #   with:
      #     host: ${{ secrets.EC2_HOST }}
      #     username: ec2-user
      #     key: ${{ secrets.EC2_SSH_KEY }}
      #     source: "docker-compose.yml,.env" 
      #     target: "~/stagelog-api"
      #     strip_components: 0 # 폴더 구조 유지

      

      # - name: Deploy via SSH
      #   uses: appleboy/ssh-action@v1.0.3
      #   with:
      #     host: ${{ secrets.EC2_HOST }}
      #     username: ec2-user
      #     key: ${{ secrets.EC2_SSH_KEY }}
      #     script: |
      #       set -e #명령어 실패시 즉시종료
      #       cd ~/stagelog-api
      #       echo ${{ secrets.DOCKERHUB_TOKEN }} | sudo docker login -u ${{ secrets.DOCKERHUB_USERNAME }} --password-stdin
      #       sudo docker-compose pull
      #       sudo docker-compose up -d
      #       sudo docker image prune -f

      # - name: Remove GitHub IP
      #   if: always()
      #   run: |
      #     aws ec2 revoke-security-group-ingress \
      #       --group-id ${{ secrets.AWS_SG_ID }} \

      #       --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32





